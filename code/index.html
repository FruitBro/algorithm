<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>反转字符串中的单词</title>
</head>
<body>
    <h2>反转字符串</h2>
    <p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p>
    <p>输入: "Let's take LeetCode contest"</p>
    <p>输出: "s'teL ekat edoCteeL tsetnoc" </p>
    <p>注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。</p>
    
    <hr>
    <h2>计数二进制子串</h2>
    <p>给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。<br>重复出现的子串要计算它们出现的次数。</p>
    <script>
    示例 1 :
    输入: "00110011"
    输出: 6
    解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。

    请注意，一些重复出现的子串要计算它们出现的次数。

    另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
写出所有的可能组合
00110011
0 0110011
00 110011
001 10011
0011 0011
00110 011
索引每次往右移动一位，子输入（递归），重复找过程
算法的本质 if switch 递归
伪代码
数组（队列）
数据结构（用来保存数据和调度）
给出输入，就返回第一个符合条件的子串
    示例 2 :
    输入: "10101"
    输出: 4
    解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。
    


    字符串
    难度大的算法题目如何解？算法的本质是寻找规律并实现
    如何找到规律？发现输入和输出的关系，寻找突破点
    复杂的实现怎么办？实现是程序+数据结构的结合体 程序就是让机器按照你设定的流程去运行（和卖烧饼一样）


    字符串：
      计数二进制子串
      知识点
       String.prototype.slice
       String.prototype.match
       String.prototype.repeat
       Array.prototype.push
       RegExp
       数组在js中可以当队列用也可以当堆栈用
    </script>
    <script>
    数组 
      电话号码的组合
      给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。
      给出数字到字母的映射如下（与电话按键相同）。注意1不对应任何字母。
      例：
      输入“23”
      输出 ["ad","ae","af","bd","be","bf","cd","ce","cf"]
      思考：3的n次方 还需要用到递归
      核心代码就是两个组合之间是怎么进行组合运算的

      知识点：
      找到规律,常用算法没法用，必须找到规律
      Array.prototype.splice

    </script>
    <script>
    卡牌分组 914
    给定一副牌，每张牌上都写着一个整数。
    此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：
    * 每组都有 X 张牌。
    * 组内所有的牌上都写着相同的整数。
    仅当你可选的 X >= 2 时返回 true。

    示例 1：
    输入：[1,2,3,4,4,3,2,1]
    输出：true
    解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]

    示例 2：
    输入：[1,1,1,2,2,2,3,3]
    输出：false
    解释：没有满足要求的分组。

    示例 3：
    输入：[1]
    输出：false
    解释：没有满足要求的分组。

    示例 4：
    输入：[1,1]
    输出：true
    解释：可行的分组是 [1,1]

    示例 5：
    输入：[1,1,2,2,2,2]
    输出：true
    解释：可行的分组是 [1,1]，[2,2]，[2,2]

    提示：
    1 <= deck.length <= 10000
    0 <= deck[i] < 10000

    提示 排序，每两个一组，如果有一组的值不相同则返回false
    计算两个数a,b的最大公约数,寻找相同数量的公约数
    a=c*b+d
    d = 0 a=c*b
    d > 0 a=c*b+d b=e*d+f 
    f = 0 b=e*d
    f > 0 b=e*d+f
    a=c*(e*d)+d
    a=c*(e*d+f)+d
    
    总结：认真读题，每一个关键词都可能是突破点
    </script>
   
</body>
</html>